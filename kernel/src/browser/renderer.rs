//! HTML Renderer
//!
//! Renders HTML to the framebuffer with basic styling.

use alloc::string::{String, ToString};
use alloc::vec::Vec;
use alloc::vec;

use super::{HtmlDocument, HtmlNode, HtmlElement, HtmlLink};
use crate::framebuffer;

/// Colors for rendering
const COLOR_BG: u32 = 0xFFFFFFFF;           // White background
const COLOR_TEXT: u32 = 0xFF1A1A1A;         // Dark text
const COLOR_LINK: u32 = 0xFF0066CC;         // Blue links
const COLOR_LINK_VISITED: u32 = 0xFF551A8B; // Purple visited
const COLOR_HEADING: u32 = 0xFF000000;      // Black headings
const COLOR_CODE_BG: u32 = 0xFFF5F5F5;      // Light gray code bg
const COLOR_CODE: u32 = 0xFFD63384;         // Pink code text
const COLOR_HR: u32 = 0xFFCCCCCC;           // Gray horizontal rule
const COLOR_QUOTE_BORDER: u32 = 0xFF0066CC; // Blue quote border
const COLOR_QUOTE_BG: u32 = 0xFFF0F7FF;     // Light blue quote bg

/// Rendering context
pub struct RenderContext {
    pub x: i32,
    pub y: i32,
    pub max_width: u32,
    pub line_height: i32,
    pub font_size: FontSize,
    pub bold: bool,
    pub italic: bool,
    pub in_link: Option<String>,
    pub links: Vec<HtmlLink>,
    pub list_depth: i32,
    pub in_pre: bool,
}

#[derive(Clone, Copy, PartialEq)]
pub enum FontSize {
    Small,
    Normal,
    Large,
    H1,
    H2,
    H3,
}

impl FontSize {
    fn height(&self) -> i32 {
        match self {
            FontSize::Small => 12,
            FontSize::Normal => 16,
            FontSize::Large => 18,
            FontSize::H1 => 32,
            FontSize::H2 => 26,
            FontSize::H3 => 20,
        }
    }
}

impl RenderContext {
    pub fn new(width: u32) -> Self {
        Self {
            x: 16,
            y: 16,
            max_width: width - 32,
            line_height: 20,
            font_size: FontSize::Normal,
            bold: false,
            italic: false,
            in_link: None,
            links: Vec::new(),
            list_depth: 0,
            in_pre: false,
        }
    }
    
    fn newline(&mut self) {
        self.x = 16 + (self.list_depth * 24);
        self.y += self.line_height;
    }
    
    fn space(&mut self) {
        self.x += 6;
    }
}

/// Render HTML document to framebuffer
pub fn render_html(
    doc: &HtmlDocument,
    x: i32,
    y: i32,
    width: u32,
    height: u32,
    scroll_y: i32,
) -> Vec<HtmlLink> {
    // Clear background
    framebuffer::fill_rect(x as u32, y as u32, width, height, COLOR_BG);
    
    let mut ctx = RenderContext::new(width);
    ctx.y = y - scroll_y;
    
    // Render all nodes
    for node in &doc.nodes {
        render_node(&mut ctx, node, x, y, width, height);
    }
    
    ctx.links
}

/// Render a single node
fn render_node(
    ctx: &mut RenderContext,
    node: &HtmlNode,
    clip_x: i32,
    clip_y: i32,
    clip_w: u32,
    clip_h: u32,
) {
    match node {
        HtmlNode::Text(text) => {
            render_text(ctx, text, clip_x, clip_y, clip_w, clip_h);
        }
        HtmlNode::Element(el) => {
            render_element(ctx, el, clip_x, clip_y, clip_w, clip_h);
        }
    }
}

/// Render text content
fn render_text(
    ctx: &mut RenderContext,
    text: &str,
    clip_x: i32,
    clip_y: i32,
    clip_w: u32,
    clip_h: u32,
) {
    let color = if ctx.in_link.is_some() { COLOR_LINK } else { COLOR_TEXT };
    
    // Handle preformatted text
    if ctx.in_pre {
        for line in text.lines() {
            render_line(ctx, line, color, clip_x, clip_y, clip_w, clip_h);
            ctx.newline();
        }
        return;
    }
    
    // Normal text - word wrap
    let words: Vec<&str> = text.split_whitespace().collect();
    
    for word in words {
        let word_width = word.len() as i32 * 8; // Approximate
        
        // Word wrap
        if ctx.x + word_width > (clip_x + clip_w as i32 - 16) && ctx.x > 16 + (ctx.list_depth * 24) {
            ctx.newline();
        }
        
        render_word(ctx, word, color, clip_x, clip_y, clip_w, clip_h);
        ctx.space();
    }
}

fn render_word(
    ctx: &mut RenderContext,
    word: &str,
    color: u32,
    clip_x: i32,
    clip_y: i32,
    clip_w: u32,
    clip_h: u32,
) {
    // Check if visible
    if ctx.y + ctx.line_height < clip_y || ctx.y > clip_y + clip_h as i32 {
        ctx.x += word.len() as i32 * 8;
        return;
    }
    
    // Track link bounds
    let link_start_x = ctx.x;
    
    // Draw each character
    for c in word.chars() {
        if ctx.x >= clip_x && ctx.x < clip_x + clip_w as i32 - 8 {
            draw_char(ctx.x as u32, ctx.y as u32, c, color);
        }
        ctx.x += 8;
    }
    
    // Add link if in anchor
    if let Some(href) = &ctx.in_link {
        ctx.links.push(HtmlLink {
            href: href.clone(),
            x: link_start_x,
            y: ctx.y,
            width: (ctx.x - link_start_x) as u32,
            height: ctx.line_height as u32,
        });
        
        // Draw underline for links
        if ctx.y >= clip_y && ctx.y < clip_y + clip_h as i32 {
            framebuffer::fill_rect(
                link_start_x as u32,
                (ctx.y + ctx.line_height - 2) as u32,
                (ctx.x - link_start_x) as u32,
                1,
                COLOR_LINK,
            );
        }
    }
}

fn render_line(
    ctx: &mut RenderContext,
    line: &str,
    color: u32,
    clip_x: i32,
    clip_y: i32,
    clip_w: u32,
    clip_h: u32,
) {
    if ctx.y + ctx.line_height < clip_y || ctx.y > clip_y + clip_h as i32 {
        return;
    }
    
    for c in line.chars() {
        if ctx.x >= clip_x && ctx.x < clip_x + clip_w as i32 - 8 {
            draw_char(ctx.x as u32, ctx.y as u32, c, color);
        }
        ctx.x += 8;
    }
}

/// Render an HTML element
fn render_element(
    ctx: &mut RenderContext,
    el: &HtmlElement,
    clip_x: i32,
    clip_y: i32,
    clip_w: u32,
    clip_h: u32,
) {
    let tag = el.tag.as_str();
    
    // Skip invisible elements
    if matches!(tag, "head" | "script" | "style" | "meta" | "link" | "title") {
        return;
    }
    
    // Save context
    let saved_font = ctx.font_size;
    let saved_bold = ctx.bold;
    let saved_link = ctx.in_link.clone();
    let saved_pre = ctx.in_pre;
    
    // Apply element-specific styling
    match tag {
        // Block elements - newline before
        "html" | "body" | "div" | "section" | "article" | "nav" | "header" | "footer" | "main" => {
            // Container - just render children
        }
        
        "p" => {
            ctx.newline();
            ctx.y += 8; // Paragraph spacing
        }
        
        "br" => {
            ctx.newline();
        }
        
        "hr" => {
            ctx.newline();
            ctx.y += 8;
            if ctx.y >= clip_y && ctx.y < clip_y + clip_h as i32 {
                framebuffer::fill_rect(
                    (clip_x + 16) as u32,
                    ctx.y as u32,
                    clip_w - 32,
                    1,
                    COLOR_HR,
                );
            }
            ctx.y += 16;
            ctx.x = 16;
        }
        
        "h1" => {
            ctx.newline();
            ctx.y += 16;
            ctx.font_size = FontSize::H1;
            ctx.line_height = 40;
            ctx.bold = true;
        }
        
        "h2" => {
            ctx.newline();
            ctx.y += 12;
            ctx.font_size = FontSize::H2;
            ctx.line_height = 32;
            ctx.bold = true;
        }
        
        "h3" | "h4" | "h5" | "h6" => {
            ctx.newline();
            ctx.y += 8;
            ctx.font_size = FontSize::H3;
            ctx.line_height = 26;
            ctx.bold = true;
        }
        
        "a" => {
            if let Some(href) = el.attr("href") {
                ctx.in_link = Some(href.to_string());
            }
        }
        
        "strong" | "b" => {
            ctx.bold = true;
        }
        
        "em" | "i" => {
            ctx.italic = true;
        }
        
        "code" => {
            // Inline code styling handled in text
        }
        
        "pre" => {
            ctx.newline();
            ctx.y += 8;
            ctx.in_pre = true;
            // Draw code background
            if ctx.y >= clip_y {
                framebuffer::fill_rect(
                    (clip_x + 8) as u32,
                    ctx.y as u32,
                    clip_w - 16,
                    100, // Will be adjusted
                    COLOR_CODE_BG,
                );
            }
        }
        
        "blockquote" => {
            ctx.newline();
            ctx.y += 8;
            ctx.list_depth += 1;
            // Draw quote border
            if ctx.y >= clip_y {
                framebuffer::fill_rect(
                    (clip_x + 12) as u32,
                    ctx.y as u32,
                    4,
                    80,
                    COLOR_QUOTE_BORDER,
                );
            }
        }
        
        "ul" | "ol" => {
            ctx.newline();
            ctx.list_depth += 1;
        }
        
        "li" => {
            ctx.newline();
            // Draw bullet
            if ctx.y >= clip_y && ctx.y < clip_y + clip_h as i32 {
                let bullet_x = ctx.x - 12;
                framebuffer::fill_rect(
                    bullet_x as u32,
                    (ctx.y + 6) as u32,
                    4,
                    4,
                    COLOR_TEXT,
                );
            }
        }
        
        "img" => {
            // Show placeholder for images
            ctx.newline();
            if ctx.y >= clip_y && ctx.y < clip_y + clip_h as i32 {
                let alt = el.attr("alt").unwrap_or("[Image]");
                framebuffer::fill_rect(
                    ctx.x as u32,
                    ctx.y as u32,
                    200,
                    100,
                    0xFFEEEEEE,
                );
                for (i, c) in alt.chars().take(20).enumerate() {
                    draw_char((ctx.x + 10 + i as i32 * 8) as u32, (ctx.y + 40) as u32, c, COLOR_TEXT);
                }
            }
            ctx.y += 110;
        }
        
        "table" => {
            ctx.newline();
            ctx.y += 8;
        }
        
        "tr" => {
            ctx.newline();
        }
        
        "td" | "th" => {
            ctx.x += 16;
        }
        
        _ => {}
    }
    
    // Render children
    for child in &el.children {
        render_node(ctx, child, clip_x, clip_y, clip_w, clip_h);
    }
    
    // Restore context
    match tag {
        "h1" | "h2" | "h3" | "h4" | "h5" | "h6" => {
            ctx.newline();
            ctx.y += 8;
        }
        "p" => {
            ctx.newline();
            ctx.y += 8;
        }
        "ul" | "ol" => {
            ctx.list_depth -= 1;
            ctx.newline();
        }
        "blockquote" => {
            ctx.list_depth -= 1;
            ctx.newline();
        }
        "pre" => {
            ctx.newline();
        }
        "table" => {
            ctx.newline();
        }
        _ => {}
    }
    
    ctx.font_size = saved_font;
    ctx.line_height = saved_font.height() + 4;
    ctx.bold = saved_bold;
    ctx.in_link = saved_link;
    ctx.in_pre = saved_pre;
}

/// Draw a character (simplified - uses 8x16 font approximation)
fn draw_char(x: u32, y: u32, c: char, color: u32) {
    let font = get_char_bitmap(c);
    
    for (row, byte) in font.iter().enumerate() {
        for bit in 0..8 {
            if (byte >> (7 - bit)) & 1 != 0 {
                framebuffer::put_pixel(x + bit, y + row as u32, color);
            }
        }
    }
}

/// Get 8x16 bitmap for character (simplified font)
fn get_char_bitmap(c: char) -> [u8; 16] {
    // Basic ASCII subset
    match c {
        ' ' => [0x00; 16],
        '!' => [0x00,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x00,0x18,0x18,0x00,0x00,0x00,0x00,0x00],
        '"' => [0x00,0x66,0x66,0x66,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00],
        '#' => [0x00,0x36,0x36,0x7F,0x36,0x36,0x7F,0x36,0x36,0x00,0x00,0x00,0x00,0x00,0x00,0x00],
        '.' => [0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x00,0x00],
        ',' => [0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x08,0x10,0x00,0x00,0x00],
        ':' => [0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x00,0x00,0x00],
        ';' => [0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x18,0x18,0x08,0x10,0x00,0x00,0x00,0x00],
        '?' => [0x00,0x3C,0x66,0x06,0x0C,0x18,0x18,0x00,0x18,0x18,0x00,0x00,0x00,0x00,0x00,0x00],
        '-' => [0x00,0x00,0x00,0x00,0x00,0x7E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00],
        '_' => [0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7F,0x00,0x00,0x00,0x00],
        '/' => [0x00,0x02,0x04,0x08,0x10,0x20,0x40,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00],
        '(' => [0x00,0x0C,0x18,0x30,0x30,0x30,0x30,0x30,0x18,0x0C,0x00,0x00,0x00,0x00,0x00,0x00],
        ')' => [0x00,0x30,0x18,0x0C,0x0C,0x0C,0x0C,0x0C,0x18,0x30,0x00,0x00,0x00,0x00,0x00,0x00],
        '[' => [0x00,0x3C,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x3C,0x00,0x00,0x00,0x00,0x00,0x00],
        ']' => [0x00,0x3C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x3C,0x00,0x00,0x00,0x00,0x00,0x00],
        '<' => [0x00,0x00,0x06,0x0C,0x18,0x30,0x18,0x0C,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00],
        '>' => [0x00,0x00,0x60,0x30,0x18,0x0C,0x18,0x30,0x60,0x00,0x00,0x00,0x00,0x00,0x00,0x00],
        '=' => [0x00,0x00,0x00,0x7E,0x00,0x00,0x7E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00],
        '+' => [0x00,0x00,0x18,0x18,0x18,0x7E,0x18,0x18,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00],
        '0' => [0x00,0x3C,0x66,0x66,0x6E,0x76,0x66,0x66,0x3C,0x00,0x00,0x00,0x00,0x00,0x00,0x00],
        '1' => [0x00,0x18,0x38,0x18,0x18,0x18,0x18,0x18,0x7E,0x00,0x00,0x00,0x00,0x00,0x00,0x00],
        '2' => [0x00,0x3C,0x66,0x06,0x0C,0x18,0x30,0x60,0x7E,0x00,0x00,0x00,0x00,0x00,0x00,0x00],
        '3' => [0x00,0x3C,0x66,0x06,0x1C,0x06,0x06,0x66,0x3C,0x00,0x00,0x00,0x00,0x00,0x00,0x00],
        '4' => [0x00,0x0C,0x1C,0x3C,0x6C,0x7E,0x0C,0x0C,0x0C,0x00,0x00,0x00,0x00,0x00,0x00,0x00],
        '5' => [0x00,0x7E,0x60,0x7C,0x06,0x06,0x06,0x66,0x3C,0x00,0x00,0x00,0x00,0x00,0x00,0x00],
        '6' => [0x00,0x1C,0x30,0x60,0x7C,0x66,0x66,0x66,0x3C,0x00,0x00,0x00,0x00,0x00,0x00,0x00],
        '7' => [0x00,0x7E,0x06,0x0C,0x18,0x30,0x30,0x30,0x30,0x00,0x00,0x00,0x00,0x00,0x00,0x00],
        '8' => [0x00,0x3C,0x66,0x66,0x3C,0x66,0x66,0x66,0x3C,0x00,0x00,0x00,0x00,0x00,0x00,0x00],
        '9' => [0x00,0x3C,0x66,0x66,0x66,0x3E,0x06,0x0C,0x38,0x00,0x00,0x00,0x00,0x00,0x00,0x00],
        'A' | 'a' => [0x00,0x18,0x3C,0x66,0x66,0x7E,0x66,0x66,0x66,0x00,0x00,0x00,0x00,0x00,0x00,0x00],
        'B' | 'b' => [0x00,0x7C,0x66,0x66,0x7C,0x66,0x66,0x66,0x7C,0x00,0x00,0x00,0x00,0x00,0x00,0x00],
        'C' | 'c' => [0x00,0x3C,0x66,0x60,0x60,0x60,0x60,0x66,0x3C,0x00,0x00,0x00,0x00,0x00,0x00,0x00],
        'D' | 'd' => [0x00,0x78,0x6C,0x66,0x66,0x66,0x66,0x6C,0x78,0x00,0x00,0x00,0x00,0x00,0x00,0x00],
        'E' | 'e' => [0x00,0x7E,0x60,0x60,0x7C,0x60,0x60,0x60,0x7E,0x00,0x00,0x00,0x00,0x00,0x00,0x00],
        'F' | 'f' => [0x00,0x7E,0x60,0x60,0x7C,0x60,0x60,0x60,0x60,0x00,0x00,0x00,0x00,0x00,0x00,0x00],
        'G' | 'g' => [0x00,0x3C,0x66,0x60,0x60,0x6E,0x66,0x66,0x3E,0x00,0x00,0x00,0x00,0x00,0x00,0x00],
        'H' | 'h' => [0x00,0x66,0x66,0x66,0x7E,0x66,0x66,0x66,0x66,0x00,0x00,0x00,0x00,0x00,0x00,0x00],
        'I' | 'i' => [0x00,0x7E,0x18,0x18,0x18,0x18,0x18,0x18,0x7E,0x00,0x00,0x00,0x00,0x00,0x00,0x00],
        'J' | 'j' => [0x00,0x3E,0x0C,0x0C,0x0C,0x0C,0x0C,0x6C,0x38,0x00,0x00,0x00,0x00,0x00,0x00,0x00],
        'K' | 'k' => [0x00,0x66,0x6C,0x78,0x70,0x78,0x6C,0x66,0x66,0x00,0x00,0x00,0x00,0x00,0x00,0x00],
        'L' | 'l' => [0x00,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x7E,0x00,0x00,0x00,0x00,0x00,0x00,0x00],
        'M' | 'm' => [0x00,0x63,0x77,0x7F,0x6B,0x63,0x63,0x63,0x63,0x00,0x00,0x00,0x00,0x00,0x00,0x00],
        'N' | 'n' => [0x00,0x66,0x76,0x7E,0x7E,0x6E,0x66,0x66,0x66,0x00,0x00,0x00,0x00,0x00,0x00,0x00],
        'O' | 'o' => [0x00,0x3C,0x66,0x66,0x66,0x66,0x66,0x66,0x3C,0x00,0x00,0x00,0x00,0x00,0x00,0x00],
        'P' | 'p' => [0x00,0x7C,0x66,0x66,0x7C,0x60,0x60,0x60,0x60,0x00,0x00,0x00,0x00,0x00,0x00,0x00],
        'Q' | 'q' => [0x00,0x3C,0x66,0x66,0x66,0x66,0x6E,0x3C,0x0E,0x00,0x00,0x00,0x00,0x00,0x00,0x00],
        'R' | 'r' => [0x00,0x7C,0x66,0x66,0x7C,0x78,0x6C,0x66,0x66,0x00,0x00,0x00,0x00,0x00,0x00,0x00],
        'S' | 's' => [0x00,0x3C,0x66,0x60,0x3C,0x06,0x06,0x66,0x3C,0x00,0x00,0x00,0x00,0x00,0x00,0x00],
        'T' | 't' => [0x00,0x7E,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00],
        'U' | 'u' => [0x00,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x3C,0x00,0x00,0x00,0x00,0x00,0x00,0x00],
        'V' | 'v' => [0x00,0x66,0x66,0x66,0x66,0x66,0x3C,0x3C,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00],
        'W' | 'w' => [0x00,0x63,0x63,0x63,0x6B,0x7F,0x77,0x63,0x63,0x00,0x00,0x00,0x00,0x00,0x00,0x00],
        'X' | 'x' => [0x00,0x66,0x66,0x3C,0x18,0x3C,0x66,0x66,0x66,0x00,0x00,0x00,0x00,0x00,0x00,0x00],
        'Y' | 'y' => [0x00,0x66,0x66,0x66,0x3C,0x18,0x18,0x18,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00],
        'Z' | 'z' => [0x00,0x7E,0x06,0x0C,0x18,0x30,0x60,0x60,0x7E,0x00,0x00,0x00,0x00,0x00,0x00,0x00],
        _ => [0x00,0x3C,0x42,0x42,0x42,0x42,0x42,0x3C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00], // Box
    }
}
