// TrustOS Transpiler - Code Generator
// Generates functional Rust code from x86_64 analysis

use alloc::string::String;
use alloc::vec::Vec;
use alloc::vec;
use alloc::format;

use super::{Instruction, SyscallInfo, BinaryType, syscall_name, Register, Operand};

/// Transpiler principal
pub struct Transpiler {
    pub instructions: Vec<Instruction>,
    pub syscalls: Vec<SyscallInfo>,
    rax_value: Option<u64>,
    rdi_value: Option<u64>,
    rsi_value: Option<u64>,
    rdx_value: Option<u64>,
}

impl Transpiler {
    pub fn new(instructions: Vec<Instruction>) -> Self {
        Self {
            instructions,
            syscalls: Vec::new(),
            rax_value: None,
            rdi_value: None,
            rsi_value: None,
            rdx_value: None,
        }
    }
    
    /// Analyse les syscalls dans les instructions
    pub fn analyze_syscalls(&mut self) {
        self.rax_value = None;
        self.rdi_value = None;
        self.rsi_value = None;
        self.rdx_value = None;
        
        for inst in &self.instructions {
            // Track register values
            if inst.mnemonic == "mov" && inst.operands.len() >= 2 {
                if let (Operand::Register(reg), Operand::Immediate(val)) = (&inst.operands[0], &inst.operands[1]) {
                    match reg {
                        Register::RAX | Register::EAX => self.rax_value = Some(*val as u64),
                        Register::RDI => self.rdi_value = Some(*val as u64),
                        Register::RSI => self.rsi_value = Some(*val as u64),
                        Register::RDX => self.rdx_value = Some(*val as u64),
                        _ => {}
                    }
                }
            }
            
            // XOR reg, reg clears register
            if inst.mnemonic == "xor" && inst.operands.len() >= 2 {
                if let (Operand::Register(r1), Operand::Register(r2)) = (&inst.operands[0], &inst.operands[1]) {
                    if r1 == r2 {
                        match r1 {
                            Register::RAX | Register::EAX => self.rax_value = Some(0),
                            Register::RDI => self.rdi_value = Some(0),
                            Register::RSI => self.rsi_value = Some(0),
                            Register::RDX => self.rdx_value = Some(0),
                            _ => {}
                        }
                    }
                }
            }
            
            // Detect syscall
            if inst.mnemonic == "syscall" {
                if let Some(num) = self.rax_value {
                    let mut args = Vec::new();
                    if let Some(v) = self.rdi_value { args.push(v); }
                    if let Some(v) = self.rsi_value { args.push(v); }
                    if let Some(v) = self.rdx_value { args.push(v); }
                    
                    self.syscalls.push(SyscallInfo {
                        address: inst.address,
                        number: num,
                        name: syscall_name(num),
                        args,
                    });
                }
            }
        }
    }
    
    /// Détecte le type de binaire
    pub fn detect_binary_type(&self) -> BinaryType {
        if self.syscalls.is_empty() {
            return BinaryType::Unknown;
        }
        
        // Only exit syscall = true/false
        if self.syscalls.len() == 1 {
            let sc = &self.syscalls[0];
            if sc.name == "exit" || sc.name == "exit_group" {
                return BinaryType::TrueFalse;
            }
        }
        
        // Check for specific patterns
        let syscall_names: Vec<&str> = self.syscalls.iter().map(|s| s.name).collect();
        
        if syscall_names.contains(&"getcwd") {
            return BinaryType::Pwd;
        }
        
        if syscall_names.contains(&"uname") {
            return BinaryType::Uname;
        }
        
        // write to stdout followed by exit = echo
        for sc in &self.syscalls {
            if sc.name == "write" && sc.args.len() > 0 && sc.args[0] == 1 {
                return BinaryType::Echo;
            }
        }
        
        BinaryType::Unknown
    }
    
    /// Génère du code Rust fonctionnel selon le type de binaire
    pub fn generate_functional_rust(&self, binary_type: BinaryType, data: &[u8]) -> String {
        let mut code = String::new();
        
        code.push_str("// Auto-generated by TrustOS Binary Transpiler\n");
        code.push_str("// This code is functionally equivalent to the original binary\n\n");
        code.push_str("#![no_std]\n#![no_main]\n\n");
        
        match binary_type {
            BinaryType::TrueFalse => {
                self.generate_true_false(&mut code);
            }
            BinaryType::Echo => {
                self.generate_echo(&mut code, data);
            }
            BinaryType::Pwd => {
                self.generate_pwd(&mut code);
            }
            BinaryType::Uname => {
                self.generate_uname(&mut code);
            }
            BinaryType::Hostname => {
                self.generate_hostname(&mut code);
            }
            BinaryType::Cat => {
                self.generate_cat(&mut code);
            }
            BinaryType::Ls => {
                self.generate_ls(&mut code);
            }
            BinaryType::Unknown => {
                self.generate_generic(&mut code);
            }
        }
        
        code
    }
    
    fn generate_true_false(&self, code: &mut String) {
        let exit_code = if let Some(sc) = self.syscalls.first() {
            if sc.args.len() > 0 { sc.args[0] as i32 } else { 0 }
        } else {
            0
        };
        
        code.push_str("/// Transpiled: exit program\n");
        code.push_str("/// Original: mov rax, 60; mov rdi, ");
        code.push_str(&format!("{}; syscall\n", exit_code));
        code.push_str("\n");
        code.push_str("use trustos_rt::prelude::*;\n\n");
        code.push_str("#[no_mangle]\n");
        code.push_str("pub extern \"C\" fn _start() -> ! {\n");
        code.push_str(&format!("    sys_exit({});\n", exit_code));
        code.push_str("}\n\n");
        code.push_str("// TrustOS native implementation\n");
        code.push_str("mod trustos_rt {\n");
        code.push_str("    pub mod prelude {\n");
        code.push_str("        pub fn sys_exit(code: i32) -> ! {\n");
        code.push_str("            // Call TrustOS exit syscall\n");
        code.push_str("            unsafe {\n");
        code.push_str("                core::arch::asm!(\n");
        code.push_str("                    \"syscall\",\n");
        code.push_str("                    in(\"rax\") 60u64,  // exit\n");
        code.push_str("                    in(\"rdi\") code as u64,\n");
        code.push_str("                    options(noreturn)\n");
        code.push_str("                );\n");
        code.push_str("            }\n");
        code.push_str("        }\n");
        code.push_str("    }\n");
        code.push_str("}\n");
    }
    
    fn generate_echo(&self, code: &mut String, data: &[u8]) {
        // Extract string from data if possible
        let message = self.extract_string_from_write(data);
        
        code.push_str("/// Transpiled: echo/print program\n");
        code.push_str("/// Original syscall: write(1, message, len)\n\n");
        code.push_str("use trustos_rt::prelude::*;\n\n");
        code.push_str("#[no_mangle]\n");
        code.push_str("pub extern \"C\" fn main(argc: i32, argv: *const *const u8) {\n");
        code.push_str("    // Echo all arguments\n");
        code.push_str("    for i in 1..argc {\n");
        code.push_str("        let arg = unsafe { *argv.offset(i as isize) };\n");
        code.push_str("        print_cstr(arg);\n");
        code.push_str("        if i < argc - 1 {\n");
        code.push_str("            print(\" \");\n");
        code.push_str("        }\n");
        code.push_str("    }\n");
        code.push_str("    println(\"\");\n");
        code.push_str("    sys_exit(0);\n");
        code.push_str("}\n\n");
        
        if !message.is_empty() {
            code.push_str(&format!("// Static message found: \"{}\"\n\n", message));
        }
        
        self.generate_runtime(code);
    }
    
    fn generate_pwd(&self, code: &mut String) {
        code.push_str("/// Transpiled: pwd - print working directory\n");
        code.push_str("/// Original syscall: getcwd(buf, size)\n\n");
        code.push_str("use trustos_rt::prelude::*;\n\n");
        code.push_str("#[no_mangle]\n");
        code.push_str("pub extern \"C\" fn main() {\n");
        code.push_str("    let cwd = sys_getcwd();\n");
        code.push_str("    println(&cwd);\n");
        code.push_str("    sys_exit(0);\n");
        code.push_str("}\n\n");
        self.generate_runtime(code);
    }
    
    fn generate_uname(&self, code: &mut String) {
        code.push_str("/// Transpiled: uname - print system information\n");
        code.push_str("/// Original syscall: uname(buf)\n\n");
        code.push_str("use trustos_rt::prelude::*;\n\n");
        code.push_str("#[no_mangle]\n");
        code.push_str("pub extern \"C\" fn main() {\n");
        code.push_str("    let info = sys_uname();\n");
        code.push_str("    print(&info.sysname);\n");
        code.push_str("    print(\" \");\n");
        code.push_str("    print(&info.nodename);\n");
        code.push_str("    print(\" \");\n");
        code.push_str("    print(&info.release);\n");
        code.push_str("    print(\" \");\n");
        code.push_str("    print(&info.version);\n");
        code.push_str("    print(\" \");\n");
        code.push_str("    println(&info.machine);\n");
        code.push_str("    sys_exit(0);\n");
        code.push_str("}\n\n");
        self.generate_runtime(code);
    }
    
    fn generate_hostname(&self, code: &mut String) {
        code.push_str("/// Transpiled: hostname\n\n");
        code.push_str("use trustos_rt::prelude::*;\n\n");
        code.push_str("#[no_mangle]\n");
        code.push_str("pub extern \"C\" fn main() {\n");
        code.push_str("    let info = sys_uname();\n");
        code.push_str("    println(&info.nodename);\n");
        code.push_str("    sys_exit(0);\n");
        code.push_str("}\n\n");
        self.generate_runtime(code);
    }
    
    fn generate_cat(&self, code: &mut String) {
        code.push_str("/// Transpiled: cat - concatenate files\n\n");
        code.push_str("use trustos_rt::prelude::*;\n\n");
        code.push_str("#[no_mangle]\n");
        code.push_str("pub extern \"C\" fn main(argc: i32, argv: *const *const u8) {\n");
        code.push_str("    if argc < 2 {\n");
        code.push_str("        // Read from stdin\n");
        code.push_str("        let mut buf = [0u8; 4096];\n");
        code.push_str("        loop {\n");
        code.push_str("            let n = sys_read(0, &mut buf);\n");
        code.push_str("            if n <= 0 { break; }\n");
        code.push_str("            sys_write(1, &buf[..n as usize]);\n");
        code.push_str("        }\n");
        code.push_str("    } else {\n");
        code.push_str("        for i in 1..argc {\n");
        code.push_str("            let path = unsafe { cstr_to_str(*argv.offset(i as isize)) };\n");
        code.push_str("            let fd = sys_open(&path, 0);\n");
        code.push_str("            if fd >= 0 {\n");
        code.push_str("                let mut buf = [0u8; 4096];\n");
        code.push_str("                loop {\n");
        code.push_str("                    let n = sys_read(fd, &mut buf);\n");
        code.push_str("                    if n <= 0 { break; }\n");
        code.push_str("                    sys_write(1, &buf[..n as usize]);\n");
        code.push_str("                }\n");
        code.push_str("                sys_close(fd);\n");
        code.push_str("            }\n");
        code.push_str("        }\n");
        code.push_str("    }\n");
        code.push_str("    sys_exit(0);\n");
        code.push_str("}\n\n");
        self.generate_runtime(code);
    }
    
    fn generate_ls(&self, code: &mut String) {
        code.push_str("/// Transpiled: ls - list directory\n\n");
        code.push_str("use trustos_rt::prelude::*;\n\n");
        code.push_str("#[no_mangle]\n");
        code.push_str("pub extern \"C\" fn main(argc: i32, argv: *const *const u8) {\n");
        code.push_str("    let path = if argc > 1 {\n");
        code.push_str("        unsafe { cstr_to_str(*argv.offset(1)) }\n");
        code.push_str("    } else {\n");
        code.push_str("        \".\"\n");
        code.push_str("    };\n");
        code.push_str("    \n");
        code.push_str("    let entries = sys_readdir(path);\n");
        code.push_str("    for entry in entries {\n");
        code.push_str("        println(&entry);\n");
        code.push_str("    }\n");
        code.push_str("    sys_exit(0);\n");
        code.push_str("}\n\n");
        self.generate_runtime(code);
    }
    
    fn generate_generic(&self, code: &mut String) {
        code.push_str("/// Transpiled: Generic binary\n");
        code.push_str("/// Syscalls detected:\n");
        for sc in &self.syscalls {
            code.push_str(&format!("///   - {} (0x{:x})\n", sc.name, sc.number));
        }
        code.push_str("\n");
        code.push_str("use trustos_rt::prelude::*;\n\n");
        code.push_str("#[no_mangle]\n");
        code.push_str("pub extern \"C\" fn main() {\n");
        
        // Generate syscall sequence
        for sc in &self.syscalls {
            match sc.name {
                "write" => {
                    let fd = sc.args.get(0).copied().unwrap_or(1);
                    code.push_str(&format!("    sys_write({}, b\"output\");\n", fd));
                }
                "read" => {
                    let fd = sc.args.get(0).copied().unwrap_or(0);
                    code.push_str(&format!("    let mut buf = [0u8; 256];\n"));
                    code.push_str(&format!("    sys_read({}, &mut buf);\n", fd));
                }
                "exit" | "exit_group" => {
                    let status = sc.args.get(0).copied().unwrap_or(0) as i32;
                    code.push_str(&format!("    sys_exit({});\n", status));
                }
                "getcwd" => {
                    code.push_str("    let cwd = sys_getcwd();\n");
                    code.push_str("    println(&cwd);\n");
                }
                "getpid" => {
                    code.push_str("    let pid = sys_getpid();\n");
                }
                "open" | "openat" => {
                    code.push_str("    let fd = sys_open(\"file\", 0);\n");
                }
                "close" => {
                    let fd = sc.args.get(0).copied().unwrap_or(3) as i32;
                    code.push_str(&format!("    sys_close({});\n", fd));
                }
                _ => {
                    code.push_str(&format!("    // TODO: {} syscall\n", sc.name));
                }
            }
        }
        
        // If no exit syscall, add one
        if !self.syscalls.iter().any(|s| s.name == "exit" || s.name == "exit_group") {
            code.push_str("    sys_exit(0);\n");
        }
        
        code.push_str("}\n\n");
        self.generate_runtime(code);
    }
    
    fn generate_runtime(&self, code: &mut String) {
        code.push_str("// TrustOS Runtime Library\n");
        code.push_str("mod trustos_rt {\n");
        code.push_str("    pub mod prelude {\n");
        code.push_str("        pub use super::*;\n");
        code.push_str("    }\n\n");
        
        code.push_str("    pub struct UnameInfo {\n");
        code.push_str("        pub sysname: &'static str,\n");
        code.push_str("        pub nodename: &'static str,\n");
        code.push_str("        pub release: &'static str,\n");
        code.push_str("        pub version: &'static str,\n");
        code.push_str("        pub machine: &'static str,\n");
        code.push_str("    }\n\n");
        
        // sys_exit
        code.push_str("    pub fn sys_exit(code: i32) -> ! {\n");
        code.push_str("        unsafe {\n");
        code.push_str("            core::arch::asm!(\n");
        code.push_str("                \"syscall\",\n");
        code.push_str("                in(\"rax\") 60u64,\n");
        code.push_str("                in(\"rdi\") code as u64,\n");
        code.push_str("                options(noreturn)\n");
        code.push_str("            );\n");
        code.push_str("        }\n");
        code.push_str("    }\n\n");
        
        // sys_write
        code.push_str("    pub fn sys_write(fd: i32, buf: &[u8]) -> isize {\n");
        code.push_str("        let ret: isize;\n");
        code.push_str("        unsafe {\n");
        code.push_str("            core::arch::asm!(\n");
        code.push_str("                \"syscall\",\n");
        code.push_str("                in(\"rax\") 1u64,\n");
        code.push_str("                in(\"rdi\") fd as u64,\n");
        code.push_str("                in(\"rsi\") buf.as_ptr(),\n");
        code.push_str("                in(\"rdx\") buf.len(),\n");
        code.push_str("                lateout(\"rax\") ret,\n");
        code.push_str("            );\n");
        code.push_str("        }\n");
        code.push_str("        ret\n");
        code.push_str("    }\n\n");
        
        // sys_read
        code.push_str("    pub fn sys_read(fd: i32, buf: &mut [u8]) -> isize {\n");
        code.push_str("        let ret: isize;\n");
        code.push_str("        unsafe {\n");
        code.push_str("            core::arch::asm!(\n");
        code.push_str("                \"syscall\",\n");
        code.push_str("                in(\"rax\") 0u64,\n");
        code.push_str("                in(\"rdi\") fd as u64,\n");
        code.push_str("                in(\"rsi\") buf.as_mut_ptr(),\n");
        code.push_str("                in(\"rdx\") buf.len(),\n");
        code.push_str("                lateout(\"rax\") ret,\n");
        code.push_str("            );\n");
        code.push_str("        }\n");
        code.push_str("        ret\n");
        code.push_str("    }\n\n");
        
        // sys_open
        code.push_str("    pub fn sys_open(path: &str, flags: i32) -> i32 {\n");
        code.push_str("        let ret: i64;\n");
        code.push_str("        unsafe {\n");
        code.push_str("            core::arch::asm!(\n");
        code.push_str("                \"syscall\",\n");
        code.push_str("                in(\"rax\") 2u64,\n");
        code.push_str("                in(\"rdi\") path.as_ptr(),\n");
        code.push_str("                in(\"rsi\") flags as u64,\n");
        code.push_str("                lateout(\"rax\") ret,\n");
        code.push_str("            );\n");
        code.push_str("        }\n");
        code.push_str("        ret as i32\n");
        code.push_str("    }\n\n");
        
        // sys_close
        code.push_str("    pub fn sys_close(fd: i32) -> i32 {\n");
        code.push_str("        let ret: i64;\n");
        code.push_str("        unsafe {\n");
        code.push_str("            core::arch::asm!(\n");
        code.push_str("                \"syscall\",\n");
        code.push_str("                in(\"rax\") 3u64,\n");
        code.push_str("                in(\"rdi\") fd as u64,\n");
        code.push_str("                lateout(\"rax\") ret,\n");
        code.push_str("            );\n");
        code.push_str("        }\n");
        code.push_str("        ret as i32\n");
        code.push_str("    }\n\n");
        
        // sys_getcwd
        code.push_str("    pub fn sys_getcwd() -> &'static str {\n");
        code.push_str("        // TrustOS implementation\n");
        code.push_str("        \"/\"\n");
        code.push_str("    }\n\n");
        
        // sys_getpid
        code.push_str("    pub fn sys_getpid() -> i32 {\n");
        code.push_str("        let ret: i64;\n");
        code.push_str("        unsafe {\n");
        code.push_str("            core::arch::asm!(\n");
        code.push_str("                \"syscall\",\n");
        code.push_str("                in(\"rax\") 39u64,\n");
        code.push_str("                lateout(\"rax\") ret,\n");
        code.push_str("            );\n");
        code.push_str("        }\n");
        code.push_str("        ret as i32\n");
        code.push_str("    }\n\n");
        
        // sys_uname
        code.push_str("    pub fn sys_uname() -> UnameInfo {\n");
        code.push_str("        UnameInfo {\n");
        code.push_str("            sysname: \"TrustOS\",\n");
        code.push_str("            nodename: \"trustos\",\n");
        code.push_str("            release: \"1.0.0\",\n");
        code.push_str("            version: \"#1 SMP Transpiled\",\n");
        code.push_str("            machine: \"x86_64\",\n");
        code.push_str("        }\n");
        code.push_str("    }\n\n");
        
        // sys_readdir
        code.push_str("    pub fn sys_readdir(_path: &str) -> &'static [&'static str] {\n");
        code.push_str("        &[\".\", \"..\"]\n");
        code.push_str("    }\n\n");
        
        // print helpers
        code.push_str("    pub fn print(s: &str) {\n");
        code.push_str("        sys_write(1, s.as_bytes());\n");
        code.push_str("    }\n\n");
        
        code.push_str("    pub fn println(s: &str) {\n");
        code.push_str("        print(s);\n");
        code.push_str("        sys_write(1, b\"\\n\");\n");
        code.push_str("    }\n\n");
        
        code.push_str("    pub fn print_cstr(s: *const u8) {\n");
        code.push_str("        if s.is_null() { return; }\n");
        code.push_str("        let mut len = 0;\n");
        code.push_str("        unsafe {\n");
        code.push_str("            while *s.offset(len) != 0 { len += 1; }\n");
        code.push_str("            let slice = core::slice::from_raw_parts(s, len as usize);\n");
        code.push_str("            sys_write(1, slice);\n");
        code.push_str("        }\n");
        code.push_str("    }\n\n");
        
        code.push_str("    pub unsafe fn cstr_to_str(s: *const u8) -> &'static str {\n");
        code.push_str("        if s.is_null() { return \"\"; }\n");
        code.push_str("        let mut len = 0isize;\n");
        code.push_str("        while *s.offset(len) != 0 { len += 1; }\n");
        code.push_str("        let slice = core::slice::from_raw_parts(s, len as usize);\n");
        code.push_str("        core::str::from_utf8_unchecked(slice)\n");
        code.push_str("    }\n");
        
        code.push_str("}\n");
    }
    
    fn extract_string_from_write(&self, data: &[u8]) -> String {
        // Try to find the string that will be written
        for sc in &self.syscalls {
            if sc.name == "write" && sc.args.len() >= 2 {
                let addr = sc.args[1];
                // This is a virtual address, we'd need to map it
                // For now, just return empty
            }
        }
        String::new()
    }
    
    /// Generate listing (assembly view)
    pub fn generate_listing(&self) -> String {
        let mut output = String::new();
        output.push_str("; TrustOS Disassembly Listing\n");
        output.push_str("; Generated by Binary Transpiler\n\n");
        
        for inst in &self.instructions {
            // Address
            output.push_str(&format!("{:016x}  ", inst.address));
            
            // Bytes
            for b in &inst.bytes {
                output.push_str(&format!("{:02x} ", b));
            }
            // Padding - avoid overflow when bytes.len() * 3 > 16
            let bytes_width = inst.bytes.len() * 3;
            if bytes_width < 16 {
                for _ in 0..(16 - bytes_width) {
                    output.push(' ');
                }
            }
            
            // Mnemonic and operands
            output.push_str(&inst.mnemonic);
            if !inst.operands.is_empty() {
                output.push_str("  ");
                for (i, op) in inst.operands.iter().enumerate() {
                    if i > 0 { output.push_str(", "); }
                    match op {
                        Operand::Register(r) => output.push_str(r.name()),
                        Operand::Immediate(v) => {
                            if *v >= 0 && *v < 256 {
                                output.push_str(&format!("{}", v));
                            } else {
                                output.push_str(&format!("0x{:x}", v));
                            }
                        }
                        Operand::Memory { base, index, scale, disp } => {
                            output.push('[');
                            if let Some(b) = base {
                                output.push_str(b.name());
                            }
                            if let Some(idx) = index {
                                output.push_str("+");
                                output.push_str(idx.name());
                                if *scale > 1 {
                                    output.push_str(&format!("*{}", scale));
                                }
                            }
                            if *disp != 0 {
                                if *disp > 0 {
                                    output.push_str(&format!("+0x{:x}", disp));
                                } else {
                                    output.push_str(&format!("-0x{:x}", -disp));
                                }
                            }
                            output.push(']');
                        }
                        Operand::Label(l) => output.push_str(l),
                    }
                }
            }
            
            // Comment
            if let Some(c) = &inst.comment {
                output.push_str(&format!("  ; {}", c));
            }
            
            output.push('\n');
        }
        
        output
    }
}
