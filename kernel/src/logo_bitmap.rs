//! TrustOS Logo Bitmap — Auto-generated by convert_logo.py
//!
//! Source image converted to embedded ARGB pixel data via binary blobs.
//! Size: 200x200 pixels, 160000 bytes (ARGB)
//!
//! Binary data loaded via include_bytes! to keep source compact.
//! Regenerate .bin files with: python convert_logo.py

/// Logo width in pixels
pub const LOGO_W: usize = 200;
/// Logo height in pixels
pub const LOGO_H: usize = 200;

/// Raw pixel bytes included at compile time (160000 bytes = 40000 × 4 bytes LE u32)
static LOGO_PIXELS_RAW: &[u8; 160000] = include_bytes!("logo_pixels.bin");

/// Access the full ARGB pixel array (200×200 = 40000 pixels)
/// Format: 0xAARRGGBB, row-major, top-to-bottom
///
/// # Safety
/// The .bin file is generated by convert_logo.py and contains exactly
/// 40000 little-endian u32 values. The alignment cast is safe because
/// we read byte-by-byte via `from_le_bytes`.
#[inline]
pub fn logo_pixel(x: usize, y: usize) -> u32 {
    let idx = (y * LOGO_W + x) * 4;
    u32::from_le_bytes([
        LOGO_PIXELS_RAW[idx],
        LOGO_PIXELS_RAW[idx + 1],
        LOGO_PIXELS_RAW[idx + 2],
        LOGO_PIXELS_RAW[idx + 3],
    ])
}

/// Provide array-like access for backward compatibility
/// Returns the pixel at flat index `i` (row-major)
#[inline]
pub fn logo_pixel_flat(i: usize) -> u32 {
    let idx = i * 4;
    u32::from_le_bytes([
        LOGO_PIXELS_RAW[idx],
        LOGO_PIXELS_RAW[idx + 1],
        LOGO_PIXELS_RAW[idx + 2],
        LOGO_PIXELS_RAW[idx + 3],
    ])
}

/// Raw mask bytes included at compile time (6400 bytes = 800 × 8 bytes LE u64)
static LOGO_MASK_RAW: &[u8; 6400] = include_bytes!("logo_mask.bin");

/// Read a u64 from the mask data
#[inline]
fn mask_word(idx: usize) -> u64 {
    let off = idx * 8;
    u64::from_le_bytes([
        LOGO_MASK_RAW[off],
        LOGO_MASK_RAW[off + 1],
        LOGO_MASK_RAW[off + 2],
        LOGO_MASK_RAW[off + 3],
        LOGO_MASK_RAW[off + 4],
        LOGO_MASK_RAW[off + 5],
        LOGO_MASK_RAW[off + 6],
        LOGO_MASK_RAW[off + 7],
    ])
}

/// Check if pixel (x, y) is in the logo silhouette
#[inline]
pub fn logo_mask_pixel(x: usize, y: usize) -> bool {
    if x >= LOGO_W || y >= LOGO_H { return false; }
    let word = x / 64;
    let bit = x % 64;
    let idx = y * 4 + word;
    (mask_word(idx) >> (63 - bit)) & 1 == 1
}

/// Check if pixel is on the edge of the logo (has a transparent/dark neighbor)
#[inline]
pub fn logo_edge_pixel(x: usize, y: usize) -> bool {
    if !logo_mask_pixel(x, y) { return false; }
    if x == 0 || !logo_mask_pixel(x - 1, y) { return true; }
    if x >= LOGO_W - 1 || !logo_mask_pixel(x + 1, y) { return true; }
    if y == 0 || !logo_mask_pixel(x, y - 1) { return true; }
    if y >= LOGO_H - 1 || !logo_mask_pixel(x, y + 1) { return true; }
    false
}
