#!/usr/bin/env python3
"""
TrustOS Logo Converter — Converts a PNG/JPG image to an embedded Rust module.

Produces kernel/src/logo_bitmap.rs containing:
  - LOGO_W, LOGO_H constants
  - LOGO_PIXELS: [u32; W*H] — full ARGB pixel data (for splash/watermark)
  - LOGO_MASK: [u64; H] — 1-bit silhouette mask (for matrix rain overlay)
  - draw_logo() helper function

Usage:
  python convert_logo.py [input_image] [--width W] [--height H] [--mask-only]

Defaults:
  input  = trustos_logo.png (in project root)
  size   = 200x260 (preserves aspect ratio, fits in center of 1920x1080)
"""

import sys
import os
import argparse

try:
    from PIL import Image
except ImportError:
    print("ERROR: Pillow is required.  Install with:  pip install Pillow")
    sys.exit(1)


def to_argb(r, g, b, a=255):
    """Convert RGBA to 0xAARRGGBB u32."""
    return (a << 24) | (r << 16) | (g << 8) | b


def image_to_rust(img, out_path, mask_only=False, threshold=30):
    """
    Convert a PIL Image to a Rust source file.
    
    - Full ARGB pixel array for faithful rendering
    - 1-bit mask for lightweight silhouette effects (matrix rain fill, etc.)
    """
    w, h = img.size
    pixels = list(img.getdata())  # list of (R, G, B, A) or (R, G, B)

    has_alpha = img.mode == "RGBA"
    
    print(f"Image size: {w}x{h}, mode: {img.mode}, pixels: {len(pixels)}")
    
    # ── Build ARGB array and mask ──
    argb_data = []
    mask_rows = []
    
    for y in range(h):
        mask_bits = 0
        for x in range(w):
            px = pixels[y * w + x]
            if has_alpha:
                r, g, b, a = px
            else:
                r, g, b = px
                a = 255
            
            argb = to_argb(r, g, b, a)
            argb_data.append(argb)
            
            # Mask: pixel is "on" if it's not essentially black/transparent
            luminance = 0.299 * r + 0.587 * g + 0.114 * b
            is_visible = a > 40 and luminance > threshold
            if is_visible:
                # Bits stored MSB-first: bit (w-1-x) for column x
                if x < 64:
                    mask_bits |= (1 << (63 - x))
        
        mask_rows.append(mask_bits)
    
    # ── Count non-black pixels for stats ──
    visible_count = sum(1 for a in argb_data if (a >> 24) > 40 and (a & 0x00FFFFFF) > 0x101010)
    print(f"Visible pixels: {visible_count}/{w*h} ({100*visible_count//(w*h)}%)")
    
    # ── Generate Rust source ──
    lines = []
    lines.append("//! TrustOS Logo Bitmap — Auto-generated by convert_logo.py")
    lines.append("//!")
    lines.append(f"//! Source image converted to embedded ARGB pixel data.")
    lines.append(f"//! Size: {w}x{h} pixels, {w*h*4} bytes (ARGB)")
    lines.append("//!")
    lines.append("//! DO NOT EDIT — regenerate with: python convert_logo.py")
    lines.append("")
    lines.append(f"/// Logo width in pixels")
    lines.append(f"pub const LOGO_W: usize = {w};")
    lines.append(f"/// Logo height in pixels")
    lines.append(f"pub const LOGO_H: usize = {h};")
    lines.append("")
    
    if not mask_only:
        # Full ARGB pixel data
        # Compress: use RLE-like encoding for runs of same color
        lines.append(f"/// Full ARGB pixel data ({w}x{h} = {w*h} pixels)")
        lines.append(f"/// Format: 0xAARRGGBB, row-major, top-to-bottom")
        lines.append(f"pub static LOGO_PIXELS: [u32; {w * h}] = [")
        
        # Write rows with comments
        for y in range(h):
            row_start = y * w
            row_end = row_start + w
            row = argb_data[row_start:row_end]
            
            # Format as hex, 16 values per line
            hex_vals = [f"0x{v:08X}" for v in row]
            for chunk_start in range(0, len(hex_vals), 16):
                chunk = hex_vals[chunk_start:chunk_start + 16]
                suffix = "," if (y < h - 1 or chunk_start + 16 < len(hex_vals)) else ","
                prefix = "    "
                if chunk_start == 0:
                    prefix = f"    /* row {y:3d} */ "
                lines.append(f"{prefix}{', '.join(chunk)},")
        
        lines.append("];")
        lines.append("")
    
    # 1-bit silhouette mask (always generated)
    lines.append(f"/// 1-bit silhouette mask: each u64 = one row, MSB = leftmost pixel")
    lines.append(f"/// For matrix rain overlay, edge detection, glow effects")
    
    # If width > 64, we need multiple u64s per row
    masks_per_row = (w + 63) // 64
    
    if masks_per_row == 1:
        lines.append(f"pub static LOGO_MASK: [u64; {h}] = [")
        for y in range(h):
            # Recompute mask with full width support
            mask_bits = 0
            for x in range(min(w, 64)):
                px = pixels[y * w + x]
                if has_alpha:
                    r, g, b, a = px
                else:
                    r, g, b = px
                    a = 255
                luminance = 0.299 * r + 0.587 * g + 0.114 * b
                if a > 40 and luminance > threshold:
                    mask_bits |= (1 << (63 - x))
            lines.append(f"    0x{mask_bits:016X}, // row {y}")
        lines.append("];")
    else:
        # Multiple u64s per row for wide images
        total_masks = masks_per_row * h
        lines.append(f"/// {masks_per_row} u64s per row (image is {w}px wide)")
        lines.append(f"pub static LOGO_MASK: [u64; {total_masks}] = [")
        for y in range(h):
            parts = []
            for mi in range(masks_per_row):
                mask_bits = 0
                base_x = mi * 64
                for bx in range(64):
                    x = base_x + bx
                    if x >= w:
                        break
                    px = pixels[y * w + x]
                    if has_alpha:
                        r, g, b, a = px
                    else:
                        r, g, b = px
                        a = 255
                    luminance = 0.299 * r + 0.587 * g + 0.114 * b
                    if a > 40 and luminance > threshold:
                        mask_bits |= (1 << (63 - bx))
                parts.append(f"0x{mask_bits:016X}")
            lines.append(f"    {', '.join(parts)}, // row {y}")
        lines.append("];")
    
    lines.append("")    
    
    # Helper: check if pixel is in the logo mask
    if masks_per_row == 1:
        lines.append("/// Check if pixel (x, y) is in the logo silhouette")
        lines.append("#[inline]")
        lines.append("pub fn logo_mask_pixel(x: usize, y: usize) -> bool {")
        lines.append(f"    if x >= LOGO_W || y >= LOGO_H {{ return false; }}")
        lines.append(f"    if x >= 64 {{ return false; }}")
        lines.append(f"    (LOGO_MASK[y] >> (63 - x)) & 1 == 1")
        lines.append("}")
    else:
        lines.append("/// Check if pixel (x, y) is in the logo silhouette")
        lines.append("#[inline]")
        lines.append("pub fn logo_mask_pixel(x: usize, y: usize) -> bool {")
        lines.append(f"    if x >= LOGO_W || y >= LOGO_H {{ return false; }}")
        lines.append(f"    let word = x / 64;")
        lines.append(f"    let bit = x % 64;")
        lines.append(f"    let idx = y * {masks_per_row} + word;")
        lines.append(f"    (LOGO_MASK[idx] >> (63 - bit)) & 1 == 1")
        lines.append("}")
    
    lines.append("")
    
    # Edge detection helper
    lines.append("/// Check if pixel is on the edge of the logo (has a transparent/dark neighbor)")
    lines.append("#[inline]")
    lines.append("pub fn logo_edge_pixel(x: usize, y: usize) -> bool {")
    lines.append("    if !logo_mask_pixel(x, y) { return false; }")
    lines.append("    if x == 0 || !logo_mask_pixel(x - 1, y) { return true; }")
    lines.append(f"    if x >= LOGO_W - 1 || !logo_mask_pixel(x + 1, y) {{ return true; }}")
    lines.append("    if y == 0 || !logo_mask_pixel(x, y - 1) { return true; }")
    lines.append(f"    if y >= LOGO_H - 1 || !logo_mask_pixel(x, y + 1) {{ return true; }}")
    lines.append("    false")
    lines.append("}")
    lines.append("")
    
    if not mask_only:
        # Draw function
        lines.append("/// Draw the full-color logo at position (px, py) onto the framebuffer")
        lines.append("/// with optional alpha blending")
        lines.append("pub fn draw_logo(px: u32, py: u32) {")
        lines.append("    for y in 0..LOGO_H {")
        lines.append("        for x in 0..LOGO_W {")
        lines.append("            let argb = LOGO_PIXELS[y * LOGO_W + x];")
        lines.append("            let a = (argb >> 24) & 0xFF;")
        lines.append("            if a < 8 { continue; } // skip fully transparent")
        lines.append("            let dx = px + x as u32;")
        lines.append("            let dy = py + y as u32;")
        lines.append("            if a >= 240 {")
        lines.append("                // Opaque — direct write")
        lines.append("                crate::framebuffer::put_pixel(dx, dy, argb);")
        lines.append("            } else {")
        lines.append("                // Alpha blend")
        lines.append("                let bg = crate::framebuffer::get_pixel(dx, dy);")
        lines.append("                let blended = alpha_blend(argb, bg);")
        lines.append("                crate::framebuffer::put_pixel(dx, dy, blended);")
        lines.append("            }")
        lines.append("        }")
        lines.append("    }")
        lines.append("}")
        lines.append("")
        lines.append("/// Draw the logo centered at (cx, cy)")
        lines.append("pub fn draw_logo_centered(cx: u32, cy: u32) {")
        lines.append(f"    let px = cx.saturating_sub({w // 2});")
        lines.append(f"    let py = cy.saturating_sub({h // 2});")
        lines.append("    draw_logo(px, py);")
        lines.append("}")
        lines.append("")
        
        # Draw with glow effect
        lines.append("/// Draw the logo with a green glow effect (for matrix rain background)")
        lines.append("pub fn draw_logo_glow(px: u32, py: u32, glow_intensity: u8) {")
        lines.append("    let gi = glow_intensity as u32;")
        lines.append("    // Draw glow halo first (2px radius around edges)")
        lines.append("    for y in 0..LOGO_H {")
        lines.append("        for x in 0..LOGO_W {")
        lines.append("            if logo_edge_pixel(x, y) {")
        lines.append("                let glow_color = 0xFF000000 | ((gi.min(255)) << 8);")
        lines.append("                // Draw glow in 3x3 around edge pixels")
        lines.append("                for dy in 0..3u32 {")
        lines.append("                    for dx in 0..3u32 {")
        lines.append("                        let gx = px + x as u32 + dx;")
        lines.append("                        let gy = py + y as u32 + dy;")
        lines.append("                        if gx > 0 && gy > 0 {")
        lines.append("                            let bg = crate::framebuffer::get_pixel(gx - 1, gy - 1);")
        lines.append("                            let blended = alpha_blend(0x40000000 | ((gi.min(180)) << 8), bg);")
        lines.append("                            crate::framebuffer::put_pixel(gx - 1, gy - 1, blended);")
        lines.append("                        }")
        lines.append("                    }")
        lines.append("                }")
        lines.append("            }")
        lines.append("        }")
        lines.append("    }")
        lines.append("    // Then draw the actual logo on top")
        lines.append("    draw_logo(px, py);")
        lines.append("}")
        lines.append("")
        
        # Alpha blend helper
        lines.append("/// Alpha-blend foreground over background (both ARGB)")
        lines.append("#[inline]")
        lines.append("fn alpha_blend(fg: u32, bg: u32) -> u32 {")
        lines.append("    let a = (fg >> 24) & 0xFF;")
        lines.append("    if a == 0 { return bg; }")
        lines.append("    if a >= 255 { return fg; }")
        lines.append("    let inv_a = 255 - a;")
        lines.append("    let r = ((((fg >> 16) & 0xFF) * a + ((bg >> 16) & 0xFF) * inv_a) / 255) & 0xFF;")
        lines.append("    let g = ((((fg >> 8) & 0xFF) * a + ((bg >> 8) & 0xFF) * inv_a) / 255) & 0xFF;")
        lines.append("    let b = (((fg & 0xFF) * a + (bg & 0xFF) * inv_a) / 255) & 0xFF;")
        lines.append("    0xFF000000 | (r << 16) | (g << 8) | b")
        lines.append("}")
    
    lines.append("")
    
    # Write file
    content = "\n".join(lines) + "\n"
    with open(out_path, "w", encoding="utf-8") as f:
        f.write(content)
    
    file_size_kb = len(content) / 1024
    data_size_kb = w * h * 4 / 1024
    print(f"Output: {out_path}")
    print(f"  Source file: {file_size_kb:.1f} KB")
    print(f"  Pixel data:  {data_size_kb:.1f} KB ({w*h} pixels)")
    print(f"  Mask data:   {masks_per_row * h * 8 / 1024:.1f} KB")
    return w, h


def main():
    parser = argparse.ArgumentParser(description="Convert logo image to Rust embedded bitmap")
    parser.add_argument("input", nargs="?", default="trustos_logo.png",
                        help="Input image (PNG/JPG/BMP)")
    parser.add_argument("--width", "-W", type=int, default=200,
                        help="Target width (default: 200)")
    parser.add_argument("--height", "-H", type=int, default=0,
                        help="Target height (0 = auto from aspect ratio)")
    parser.add_argument("--output", "-o", type=str,
                        default="kernel/src/logo_bitmap.rs",
                        help="Output Rust file")
    parser.add_argument("--mask-only", action="store_true",
                        help="Only generate the 1-bit mask (no pixel data)")
    parser.add_argument("--threshold", "-t", type=int, default=25,
                        help="Luminance threshold for mask (0-255, default: 25)")
    parser.add_argument("--no-resize", action="store_true",
                        help="Keep original image dimensions")
    args = parser.parse_args()
    
    # Find input image
    script_dir = os.path.dirname(os.path.abspath(__file__))
    input_path = args.input
    if not os.path.isabs(input_path):
        input_path = os.path.join(script_dir, input_path)
    
    if not os.path.exists(input_path):
        print(f"ERROR: Image not found: {input_path}")
        print(f"  Place the logo image in the project root, or pass a path.")
        sys.exit(1)
    
    print(f"Loading: {input_path}")
    img = Image.open(input_path)
    
    # Convert to RGBA
    if img.mode != "RGBA":
        img = img.convert("RGBA")
    
    orig_w, orig_h = img.size
    print(f"Original size: {orig_w}x{orig_h}")
    
    if not args.no_resize:
        target_w = args.width
        if args.height > 0:
            target_h = args.height
        else:
            # Preserve aspect ratio
            target_h = int(orig_h * target_w / orig_w)
        
        print(f"Resizing to: {target_w}x{target_h}")
        img = img.resize((target_w, target_h), Image.LANCZOS)
    
    # Output path
    out_path = args.output
    if not os.path.isabs(out_path):
        out_path = os.path.join(script_dir, out_path)
    
    w, h = image_to_rust(img, out_path, mask_only=args.mask_only, threshold=args.threshold)
    
    print()
    print("=" * 60)
    print(f"  Logo converted: {w}x{h}")
    print(f"  Output: {out_path}")
    print()
    print("  To use in TrustOS kernel:")
    print("    1. Add 'pub mod logo_bitmap;' to kernel/src/lib.rs or main.rs")
    print("    2. Use logo_bitmap::draw_logo(x, y) or draw_logo_centered(cx, cy)")
    print("    3. Use logo_bitmap::draw_logo_glow(x, y, intensity) for matrix effect")
    print("    4. Use logo_bitmap::logo_mask_pixel(x, y) for silhouette checks")
    print("=" * 60)


if __name__ == "__main__":
    main()
