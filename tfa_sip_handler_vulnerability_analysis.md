# ARM Trusted Firmware (TF-A) SiP Handler Vulnerability Analysis
## Pattern: Missing Address Validation in SMC Handlers (Altera/Intel-style)

**Date:** 2026-02-28  
**Reference Bug:** Intel/Altera SiP handler — `is_address_in_ddr_range()` missing or bypassed for NS-world-supplied memory addresses used in `mmio_write`/`mmio_read`/mailbox operations.

---

## 1. Platforms with Publicly Visible SiP Service Code

| Platform | SiP Handler File(s) | Publicly Visible |
|----------|---------------------|-----------------|
| **Intel/Altera (SoCFPGA)** | `plat/intel/soc/common/socfpga_sip_svc.c`, `sip/socfpga_sip_fcs.c` | ✅ Yes |
| **MediaTek** | `plat/mediatek/common/mtk_sip_svc.c` + per-SoC `plat_sip_calls.c` (mt8173, mt8192, etc.) | ✅ Yes |
| **Rockchip** | `plat/rockchip/common/rockchip_sip_svc.c` + per-SoC drivers | ✅ Yes |
| **NXP (Layerscape)** | `plat/nxp/common/sip_svc/sip_svc.c` | ✅ Yes |
| **NVIDIA Tegra** | `plat/nvidia/tegra/common/tegra_sip_calls.c` | ✅ Yes |
| **NXP i.MX** | `plat/imx/common/imx_sip_svc.c` | ✅ Yes |
| **Xilinx/AMD (Versal/ZynqMP)** | `plat/xilinx/common/pm_service/pm_svc_main.c`, `custom_sip_svc.c` | ✅ Yes |
| **Marvell (Armada)** | `plat/marvell/armada/common/mrvl_sip_svc.c` | ✅ Yes |
| **Broadcom (Stingray)** | `plat/brcm/common/` (no SiP handler file found) | ⚠️ Partial — no SiP handler in public repo |
| **Allwinner** | `plat/allwinner/common/` (no SiP handler found) | ⚠️ No SiP handler in public repo |
| **HiSilicon (HiKey/HiKey960)** | `plat/hisilicon/` (no SiP handler found) | ⚠️ No SiP handler in public repo |
| **Qualcomm (QTI)** | `plat/qti/common/` (handler not publicly accessible) | ❌ Closed/private |

---

## 2. Per-Platform Address Validation Analysis

### ✅ Intel/Altera SoCFPGA — REFERENCE VULNERABLE PLATFORM (now partially fixed)

**File:** `plat/intel/soc/common/socfpga_sip_svc.c`

**Validation Found:**
- `is_address_in_ddr_range()` — validates addr + size is within `[BL31_LIMIT, DRAM_BASE+DRAM_SIZE)` and doesn't overflow.
- `is_out_of_sec_range()` — whitelist-based register address check for `INTEL_SIP_SMC_REG_READ`/`REG_WRITE`.
- Used in `intel_fpga_config_write()`, `intel_mbox_send_cmd()`, `intel_smc_service_completed()`.

**Gaps / Issues:**
1. **`is_out_of_sec_range()` returns 0 in DEBUG builds** — `#if DEBUG return 0;` bypasses ALL register access checking in debug firmware. This is a known weakness.
2. **`INTEL_SIP_SMC_FPGA_CONFIG_WRITE`** — calls `intel_fpga_config_write(x1, x2)` which does check `is_address_in_ddr_range(mem, size)`. ✅
3. **`intel_fpga_config_start()`** — `x1` (flag) is not an address; OK.
4. **V3 API `ALTERA_SIP_SMC_ASYNC_QSPI_WRITE`** — `uint32_t *qspi_payload = (uint32_t *)x2;` — **x2 cast to pointer and dereferenced** (`qspi_payload[0]`, `qspi_payload[1]`). **No `is_address_in_ddr_range()` check on x2.** This is a potential read-from-arbitrary-address vulnerability.
5. **V3 API `ALTERA_SIP_SMC_ASYNC_QSPI_GET_DEV_INFO`** — `uint32_t *dst_addr = (uint32_t *)x2;` passed as callback buffer. **No DDR range check.**
6. **V3 API `ALTERA_SIP_SMC_ASYNC_QSPI_READ`** — `(uint32_t *)x3` used as response buffer. **No DDR range check.**
7. **V3 API `ALTERA_SIP_SMC_ASYNC_FCS_GET_PROVISION_DATA`** — `(uint32_t *)x2` used as response buffer. **No DDR range check.**
8. **V3 API `ALTERA_SIP_SMC_ASYNC_FCS_RANDOM_NUMBER_EXT`** — `ret_random_addr = (uint64_t)x4` — validates `random_len` but **no DDR range check on `ret_random_addr` itself**. The firmware will write random bytes to an attacker-controlled address.
9. **V3 API `ALTERA_SIP_SMC_ASYNC_GEN_MBOX_CMD`** — `cmd_payload_addr = (uint32_t *)x3`, `resp_payload_addr = (uint32_t *)x5` — only NULL checks, **no DDR range validation**. This is a generic mailbox command that reads from and writes to attacker-supplied addresses.
10. **V3 API `ALTERA_SIP_SMC_ASYNC_MCTP_MSG`** — `*src_addr = (uint32_t *)x2`, `*dst_addr = (uint32_t *)x4` — **no DDR range check on either**.

**Severity: HIGH** — Multiple V3 API paths use NS-supplied addresses as pointer targets without bounds checking.

---

### ⚠️ NVIDIA Tegra — MIXED (partially validated)

**File:** `plat/nvidia/tegra/common/tegra_sip_calls.c` + `tegra_bl31_setup.c`

**Validation Found:**
- `bl31_check_ns_address(base, size)` — validates address is in `[TEGRA_DRAM_BASE, TEGRA_DRAM_END)`, doesn't overlap TZDRAM.
- Used for `TEGRA_SIP_NEW_VIDEOMEM_REGION` — **properly validated** with `bl31_check_ns_address(x1, local_x2_32)`. ✅

**Gaps / Issues:**
1. **`TEGRA_SIP_FIQ_NS_ENTRYPOINT`** — `x1` is stored as the NS FIQ handler entrypoint via `tegra_fiq_set_ns_entrypoint(x1)`. The code has a **TODO comment**: `"TODO: Check if x1 contains a valid DRAM address"`. **Address is NOT validated.** An attacker could set an arbitrary entrypoint that gets jumped to on FIQ.
2. **`plat_sip_handler()`** (SoC-specific, called first) — would need per-SoC analysis; not visible in common code.

**Severity: MEDIUM** — The FIQ entrypoint TODO is a known documented gap. The video memory region handler is properly protected.

---

### ⚠️ NXP Layerscape — MIXED

**File:** `plat/nxp/common/sip_svc/sip_svc.c`

**Validation Found:**
- Caller type checked via `is_caller_non_secure(flags)`.
- `SIP_SVC_HUK` — explicitly requires `ns == 0` (secure world only). ✅

**Gaps / Issues:**
1. **`SIP_SVC_HUK`** — `get_hw_unq_key_blob_hw((uint8_t *) x1, (uint32_t) x2)` — x1 is cast to a pointer. Although the `ns != 0` check blocks non-secure callers, if this is ever misconfigured or the check is bypassed, x1 is used as a write target without bounds checking.
2. **`SIP_SVC_MEM_BANK`** — x1 is used as an index (`info_dram_regions->region[x1]`). Bounds-checked against `num_dram_regions`. ✅
3. **`SIP_SVC_2_AARCH32`** — `el2_2_aarch32(smc_fid, x1, x2, x3)` — x1 is `start_addr`. No visible validation of whether this address is in Non-Secure DRAM.
4. **`nxp_plat_sip_handler()`** — weak symbol that platform implementations override. Would need per-platform analysis.

**Severity: LOW-MEDIUM** — Most sensitive operations are secure-only, but the `el2_2_aarch32` entry point address lacks visible validation.

---

### ✅ MediaTek — GOOD VALIDATION (whitelist pattern)

**File:** `plat/mediatek/common/mtk_sip_svc.c` + `plat/mediatek/mt8173/plat_sip_calls.c`

**Validation Found:**
- **`mt_sip_set_authorized_sreg(sreg, val)`** — uses a **hardcoded whitelist** (`authorized_sreg[]`) of allowed register addresses. Only registers explicitly in the whitelist can be written via `mmio_write_32`. **Excellent pattern.** ✅
- Per-platform handlers (mt8173) use this pattern.
- mt8192: `apusys_kernel_ctrl()` uses `request_ops` as a command enum, not as an address. `mmio_write_32` calls use hardcoded addresses. ✅
- Recent commit (visible in plat listing): `"fix(mt8196): check apusys_ace_he_config address is valid"` — suggests mt8196 had a missing validation that was recently fixed.

**Gaps / Issues:**
1. **mt8173 `crypt_set_hdcp_key_ex(x1, x2, x3)`** — x1/x2/x3 passed to crypto function. Need to check inner implementation for pointer dereference.
2. **mt8173 `wdt_smc_handler(x1, x2, handle)`** — watchdog handler receives args. Need inner implementation review.
3. **mt8196** — recently patched for missing address validation (commit message: "check apusys_ace_he_config address is valid"). This means there WAS a vulnerability.

**Severity: LOW** — The whitelist pattern for register access is a security best practice. Recent mt8196 fix shows ongoing attention to this attack surface.

---

### ⚠️ Rockchip — OPAQUE (delegates to platform-specific handler)

**File:** `plat/rockchip/common/rockchip_sip_svc.c`

**Validation Found:**
- Rejects secure-world callers: `if (!ns) SMC_RET1(handle, SMC_UNK);` — only accepts NS calls. ✅
- Common handler only has `SIP_SVC_CALL_COUNT`, `SIP_SVC_UID`, `SIP_SVC_VERSION`.

**Gaps:**
- All actual functionality delegated to `rockchip_plat_sip_handler()` (weak symbol). The per-SoC implementations (rk3399, rk3588, etc.) contain the actual SMC handling logic.
- `plat/rockchip/rk3399/drivers/soc/soc.c` — hardware init code uses `mmio_write_32` extensively with hardcoded addresses (PLL config, etc.), not user-supplied. ✅
- However, the actual SiP DRAM frequency scaling handlers (likely in `dram.c`/`dfs.c`) would need separate analysis.

**Severity: UNKNOWN** — Common layer is clean, but per-SoC analysis needed.

---

### ✅ NXP i.MX — MOSTLY SAFE (dispatch pattern)

**File:** `plat/imx/common/imx_sip_svc.c`

**Analysis:**
- Handler dispatches to platform-specific sub-handlers like `imx_gpc_handler()`, `dram_dvfs_handler()`, `imx_src_handler()`, etc.
- None of the visible dispatch paths directly use x1-x4 as memory addresses for mmio operations in the common handler.
- Sub-handlers would need individual analysis.

**Severity: LOW** — No direct address-as-pointer patterns visible in common handler.

---

### ✅ Marvell Armada — GOOD VALIDATION

**File:** `plat/marvell/armada/common/mrvl_sip_svc.c`

**Validation Found:**
- **`is_cp_range_valid()`** — validates that COMPHY base addresses (from x1) correspond to valid CP base addresses. ✅
- Lane number (x2) bounds-checked: `x2 >= MAX_LANE_NR`. ✅
- `MV_SIP_DDR_PHY_WRITE`/`MV_SIP_DDR_PHY_READ` — x1 used as PHY register offset. Would need to check if `mvebu_ddr_phy_write/read` validates the offset.
- `MV_SIP_DFX` — dispatches to `mvebu_dfx_thermal_handle()` / `mvebu_dfx_misc_handle()` with x2/x3. Inner validation needed.

**Severity: LOW** — Good validation patterns visible. COMPHY addresses properly validated.

---

### ⚠️ Xilinx/AMD (Versal/ZynqMP) — MIXED

**File:** `plat/xilinx/common/pm_service/pm_svc_main.c`

**Analysis:**
- The PM service is primarily an IPI-based message-passing interface to the Platform Management Controller (PMC).
- SMC arguments are packed into IPI payloads and sent to PMC firmware.
- The TF-A layer does **not** directly dereference NS addresses as pointers or use them for mmio operations.
- **Security flag** properly set: `security_flag = SECURE/NON_SECURE` based on caller.
- The PMC firmware is responsible for validating addresses in the IPI payloads.

**Gaps:**
- `PM_LOAD_PDI` — passes `pm_arg[1], pm_arg[2]` (which could be addresses) to PMC via IPI. TF-A doesn't validate them.
- Trust boundary is deferred to PMC firmware — if PMC doesn't validate, addresses could be arbitrary.

**Severity: LOW-MEDIUM** — Address validation is deferred to the co-processor (PMC). The TF-A layer itself doesn't use addresses directly for memory operations.

---

## 3. Summary of Specific Vulnerable Patterns Found

### HIGH SEVERITY

| Platform | Function/SMC | Issue |
|----------|-------------|-------|
| **Intel/Altera** | `ALTERA_SIP_SMC_ASYNC_QSPI_WRITE` (V3) | `x2` cast to `uint32_t*` and dereferenced — no `is_address_in_ddr_range()` check |
| **Intel/Altera** | `ALTERA_SIP_SMC_ASYNC_GEN_MBOX_CMD` (V3) | `x3` and `x5` used as cmd/resp buffer pointers — only NULL check, no DDR range check |
| **Intel/Altera** | `ALTERA_SIP_SMC_ASYNC_QSPI_READ` (V3) | `x3` used as response buffer — no DDR range check |
| **Intel/Altera** | `ALTERA_SIP_SMC_ASYNC_QSPI_GET_DEV_INFO` (V3) | `x2` used as response buffer — no DDR range check |
| **Intel/Altera** | `ALTERA_SIP_SMC_ASYNC_FCS_RANDOM_NUMBER_EXT` (V3) | `x4` (ret_random_addr) used as write target — no DDR range check; size is validated but address is not |
| **Intel/Altera** | `ALTERA_SIP_SMC_ASYNC_FCS_GET_PROVISION_DATA` (V3) | `x2` used as response buffer — no DDR range check |
| **Intel/Altera** | `ALTERA_SIP_SMC_ASYNC_MCTP_MSG` (V3) | Both `x2` (src) and `x4` (dst) used as pointers — no DDR range check |
| **Intel/Altera** | `is_out_of_sec_range()` | Returns 0 (allow all) when `#if DEBUG` — complete bypass in debug builds |

### MEDIUM SEVERITY

| Platform | Function/SMC | Issue |
|----------|-------------|-------|
| **NVIDIA Tegra** | `TEGRA_SIP_FIQ_NS_ENTRYPOINT` | `x1` stored as NS FIQ entry point without address validation (documented TODO) |
| **NXP Layerscape** | `SIP_SVC_2_AARCH32` | `x1` (start_addr) passed to `el2_2_aarch32()` without visible validation |
| **MediaTek mt8196** | APUSys handler | Recently patched missing address validation (commit: "check apusys_ace_he_config address is valid") |

### LOW / INFORMATIONAL

| Platform | Note |
|----------|------|
| **MediaTek (general)** | Whitelist-based `authorized_sreg[]` is excellent security pattern |
| **Marvell** | `is_cp_range_valid()` properly validates COMPHY base addresses |
| **NVIDIA Tegra** | `bl31_check_ns_address()` is a well-implemented DRAM range check |
| **Intel/Altera (V1)** | V1 API paths generally have `is_address_in_ddr_range()` checks — the missing checks are concentrated in the newer V3 API |

---

## 4. Platforms Not in Public TF-A Repository (Closed Source)

| Platform | Status |
|----------|--------|
| **Qualcomm (QTI)** | Directory structure exists (`plat/qti/common/`) but SiP handler not publicly visible (likely proprietary QTEE/QHEE) |
| **Samsung (Exynos)** | Not present in TF-A repo at all — uses proprietary EL3 firmware |
| **Apple** | Not present — uses proprietary secure firmware |
| **Broadcom** | Partial presence (`plat/brcm/`) — has BL2/BL31 setup but no SiP handler found; Stingray-specific handler may be proprietary |
| **Allwinner** | Platform code present but no SiP SMC handler — uses PSCI-only interface via SCPI |
| **HiSilicon** | Platform code for HiKey/HiKey960/Poplar present but no visible SiP handler |
| **Amlogic** | Present in repo but would need separate analysis |
| **TI (Texas Instruments)** | Present in repo but would need separate analysis |

---

## 5. Key Takeaways

1. **The Intel/Altera V3 SiP API has the most critical missing validations** — multiple SMC handlers cast NS-supplied arguments to pointers without `is_address_in_ddr_range()` checks. This is the same class of bug as the original Altera vulnerability, just in newer API paths.

2. **The `#if DEBUG return 0` pattern in `is_out_of_sec_range()`** is dangerous — if debug firmware ships to production, all register access controls are disabled.

3. **MediaTek's whitelist approach** (`authorized_sreg[]`) is the most secure pattern seen — only explicitly enumerated register addresses can be accessed.

4. **NVIDIA's `bl31_check_ns_address()`** is a good model but has a documented TODO gap for the FIQ entrypoint handler.

5. **The V3 async mailbox API pattern** (Intel/Altera) is inherently risky — it takes callback buffer addresses from NS world and writes mailbox responses to them. Every such path needs DDR range validation.

6. **Several platforms delegate to co-processors** (Xilinx to PMC, MediaTek to SCP) — the TF-A layer may not validate addresses, relying on the co-processor to do so. This is a weaker security model.
